<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3Dキャラ スクロール連動</title>
  <style>
    body { margin: 0; height: 200vh; background: black; }
    canvas { display: block; }
    #debug {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      font-size: 14px;
      border-radius: 5px;
      z-index: 10;
    }
  </style>
  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
  <!-- GLTFLoader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <!-- DRACOLoader（Draco圧縮対応） -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/DRACOLoader.js"></script>
  <!-- lil-gui -->
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18"></script>
</head>
<body>
  <div id="debug">
    <div>Scroll: <span id="scrollProgress">0%</span></div>
    <div>Frame: <span id="currentFrame">0 / 24</span></div>
  </div>

  <script>
    let scene, camera, renderer, model, mixer, animationAction;
    let scrollY = 0, targetScrollY = 0;
    let gui;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); // 背景黒

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.5, 5); 
      camera.lookAt(0, 1, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // ライト
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(5, 10, 7.5);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.2));

      // GLTFLoader + DRACOLoader
      const loader = new THREE.GLTFLoader();
      const dracoLoader = new THREE.DRACOLoader();
      dracoLoader.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.4.3/");
      loader.setDRACOLoader(dracoLoader);

      loader.load("models/iori.glb", (gltf) => {
        model = gltf.scene;

        // デフォルトサイズ・位置
        model.scale.set(1, 1, 1);
        model.position.set(0, 0, 0);

        scene.add(model);

        mixer = new THREE.AnimationMixer(model);
        if (gltf.animations.length > 0) {
          animationAction = mixer.clipAction(gltf.animations[0]);
          animationAction.play();
          animationAction.paused = true;
        }

        // GUI作成
        setupGUI();
      });

      // スクロール監視
      window.addEventListener("scroll", () => {
        targetScrollY = window.scrollY;
      });

      window.addEventListener("resize", onWindowResize);
    }

    function setupGUI() {
      gui = new lil.GUI();

      // カメラ調整
      const camFolder = gui.addFolder("Camera");
      camFolder.add(camera.position, "x", -10, 10, 0.1).name("posX");
      camFolder.add(camera.position, "y", -10, 10, 0.1).name("posY");
      camFolder.add(camera.position, "z", -10, 10, 0.1).name("posZ");
      camFolder.open();

      // モデル調整
      const modelFolder = gui.addFolder("Model");
      modelFolder.add(model.scale, "x", 0.1, 5, 0.1).name("scaleX");
      modelFolder.add(model.scale, "y", 0.1, 5, 0.1).name("scaleY");
      modelFolder.add(model.scale, "z", 0.1, 5, 0.1).name("scaleZ");
      modelFolder.add(model.position, "x", -5, 5, 0.1).name("posX");
      modelFolder.add(model.position, "y", -5, 5, 0.1).name("posY");
      modelFolder.add(model.position, "z", -5, 5, 0.1).name("posZ");
      modelFolder.add(model.rotation, "y", -Math.PI, Math.PI, 0.01).name("rotY");
      modelFolder.open();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      scrollY += (targetScrollY - scrollY) * 0.1;
      const scrollProgress = Math.min(scrollY / (document.body.scrollHeight - window.innerHeight), 1);

      if (mixer && animationAction) {
        const duration = animationAction.getClip().duration;
        const time = scrollProgress * duration;
        animationAction.time = time;
        mixer.update(0);

        document.getElementById("scrollProgress").textContent = Math.round(scrollProgress * 100) + "%";
        document.getElementById("currentFrame").textContent = Math.round(scrollProgress * 24) + " / 24";
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
